def list_to_pow(nums, power):
    """ Возводит все элементы списка целых чисел в целую степень
    
    Аргументы:
        - nums:list - список целых чисел
        - pow:int - степень, в которую необходимо возвести числа
    
    Возвращает:
        - list целых чисел

    Указания: 
        - используйте map и lambda
        - авторское решение занимает 40 символов
    """
    # return [x**pow for x in nums]
    return list(map(lambda x: pow(x, power), nums))

def naive_encoder(n):
    """ Вычисляет n + nn + nnn для данного n. Например,
        для n = 10 вычисляет 10 + 1010 + 101010
    
    Аргументы:
        - n:int - неотрицательное целое число

    Возвращает:
        - int

    Указания:
        - используйте преобразование типов int и str друг в друга
        - авторское решение занимает 40 символов
    """
    res = (n + int(str(n)*2) + int(str(n)*3))
    return res


def fibonacci_nth(n):
    """ Вычисляет n-е число Фибоначчи
    
    Аргументы:
        - n:int - натуральное число от 1 до 10**5
    
    Возвращает:
        - int

    Указания:
        - не нужно хранить в памяти всю последовательность чисел
        - используйте множественное присваивание, например: a, b = 1, 1
        - авторское решение занимает 6 строк
    """
    a, b = 0, 1
    for _ in range(n):
        a, b = b, a + b
    return a


def clip_list(objl, a_min, a_max):
    """ Проверяет, что объекты списка objl находятся в диапазоне значений [a_min, a_max]
        Если элемент списка меньше a_min, то его значение меняется на a_min.
        Если элемент списка больше a_max, то его значение меняется на a_max.

    Аргументы:
        - objl:list - список объектов для которых определен оператор <
        - a_min - объект того же типа, что элементы списка objl
        - a_max - объект того же типа, что элементы списка objl, a_min <= a_max

    Возвращает:
        - list: список, элементы которого находятся в диапазоне значений [a_min, a_max]

    Указания:
        - Используйте функции min и max
        - способ 1:
            - используйте list comprehension
            - авторское решение занимает 48 символа
        - способ 2:
            - функцию map и lambda-функцию
            - авторское решение занимает 59 символа
    """
    # res = []
    # for x in objl:
    #     if x < a_min: x = a_min
    #     if x > a_max: x = a_max
    #     res.append(x)
    # return res
    return [max(a_min, min(x, a_max)) for x in objl]

def input_to_list():
    """ Запрашивает список целых чисел через стандартный поток в формате
        "n1, n2, n3, ..., ni", i >= 0, и преобразует его в список целых чисел

    Аргументы: отсутствуют

    Возвращает:
        - list: список целых чисел

    Указания:
        - гарантируется, что вводятся корректные данные
        - обратите внимание на случаи, когда вход подается 0 и 1 число
        - используйте функцию input и метод split типа str
        - используйте оператор in для поиска по строке
        - авторское решение занимает 6 строк
    """
    lst = input()
    if ',' not in lst and lst.strip() == '': return []
    nums = lst.split(',')
    return [int(x.strip()) for x in nums]


def income_by_client(records):
    """ Подсчитывает поступления от каждого клиента по списку всех поступлений

    Аргументы:
        - records: список (list) кортежей (tuple). Каждый кортеж состоит из
                   двух элементов: (имя клиента: str, сумма: int). Например:
                   [('John', 100), ('Anna', 251), ('John', 50)]

    Возвращает:
        - dict: словарь, ключ которого есть имя клиента, а значение - сумма 
                поступлений от этого клиента. Например:
                {'John': 150, 'Anna': 251}

    Указания:
        - авторское решение занимает 7 строк
    """
    res = {}
    for person, summ in records:
        if person in res:
            res[person] += summ
        else: 
            res[person] = summ
    return res

def add_prefix(str_list, pref):
    """ Добавляет префикс к каждой строке из списка. Строки, которые уже начинаются
        с нужного префикса, не изменяются

    Аргументы:
        - str_list:list - список строк
        - pref:str - префикс, который необходимо добавить

    Возвращает:
        - list: копию исходного списка, содержаший модифицированные строки. Строки
                должны располагаться в том же порядке, что и в исходном списке

    Указания:
        - используйте метод startswith типа str
        - способ 1: 
            - используйте комбинацию функции map и lambda-функции
            - авторское решение занимает 85 символа
        - способ 2:
            - используйте list comprehension
            - авторское решение занимает 74 символа
    """
    x = [x if x.startswith(pref) else (pref + str(x)) for x in str_list]
    return x


def hide_secrets(recodrs):
    """ Возвращает копию списка строк recodrs, из которого удалены все строки,
        содержащие `secret` в любой комбинации строчных и заглавных символов
        (например, `sEcReT` не должен проходить фильтр)

    Аргументы:
        - recodrs:list - список строк

    Возвращает:
        - list: список строк, прошедших фильтрацию, в том же порядке, в каком
                они располагались в исходном списке

    Указания:
        - используйте встроенную функцию filter в комбинации с lambda-функцией
        - используйте метод casefold или метод lower класса str
        - авторское решение занимает 68 символа
    """
    res = list(filter(lambda x: 'secret' not in x.lower(), recodrs))
    return res

def is_same_type(objlist):
    """ Возвращает True, если все объекты списка являются объектами одного типа
        и False, если список содержит хотя бы два объекта разных типов.

    Аргументы:
        - objlist:list - список объектов

    Возвращает:
        - bool

    Указания:
        - используйте встроенную функцию type
        - авторское решение занимает 39 символов
    """
    if len(objlist) == 0: return True

    init = objlist[0]
    for x in objlist:
        if type(init) != type(x):
            return False
    return True


def file_to_str_list(path):
    """ Возвращает содержимое текстового файла в виде списка строк.
        Каждая строка соответствует строке файла

    Аргументы:
        - path: полный путь до файла. Гарантируется, что файл существует

    Возвращает:
        - list: список строк файла

    Указания:
        - используйте функцию open, чтобы открыть файл
        - файловый объект - итерируемый. Итерирование происходит по строкам
        - авторское решение занимает 35 символов
    """
    with open(path, 'r') as f:
        filo = f.readlines()
    return filo